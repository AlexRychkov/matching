### CQRS
[Command Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html), literally re-categorises the traditional [CRUD](https://www.codecademy.com/articles/what-is-crud) into the followings

* Command - the intention
* Event - the validated command that result in state change
* Query - the request for information only
* Report - the result of a query

~~Events in this domain is categorised into the followings:~~
* ~~Primary event - a direct response as a result of Command validation~~ 
* ~~Side-effect event - an event generated as a side effect of playing a Primary event~~ 

Combined with Event-sourcing, the application semantics can be as the following ~~recursion~~:

* Either(Exception, Events) = execute (Command, State)
* "New State" = play (Event, State)

The `execute` function validates the command and decides which Events to be produced. The `play` function only updates the state **and absolutely nothing else**. 

There are at least four reasons for this:

* Having business logic in `play` function implies that it address two concerns in the evolution of the application - changes in business logic and changes in data structures. It violates the Single Responsibility Principle. The business logic should be moved to the `execute` function so all business logic are cohesively there and all state changes are cohesively in the `play` function.
* As `play` function is invoked during recovery, having business logic there risks inconsistent state if events generated by old business logic were re-played using new business logic in `play` function.
* Recovery would be slower if there is business logic in `play` function. 
* Moving all business logic from `play` to `execute` function means the business logic is only ever used once for an event. It would be (n + 1) times if the state were recovered n times. Why do it more than once while you could do it once only?

~~*"Primary event" = validate (Command, State)*~~

~~*"New State", "Side-effect events" = play (Event, State)*~~

The transaction is completed when all events are played and the final new state is computed.

### Recovery
~~During recovery, only Primary events need to be re-played as the Side-effect events will be re-generated.~~

Each aggregate can be recovered in isolation, given the fact that each aggregate has its own sequence of events. Events can be compacted as a snapshot to reduce the ever-growing number of events to be re-played and hence the recovery time. However, the snapshot is not planned to be implemented in this project, at least currently. This is namely the [Memento](https://refactoring.guru/design-patterns/memento) pattern.